import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ExamConfigModal } from '../ExamConfigModal';
import type { ExamConfig } from '@/types/api';

// Mock API
const mockApi = {
  getExamConfig: vi.fn(),
  setExamConfig: vi.fn(),
  updateExamConfig: vi.fn(),
  deleteExamConfig: vi.fn(),
};

vi.mock('@/lib/api', () => ({
  apiClient: mockApi,
}));

describe('ExamConfigModal', () => {
  const mockProps = {
    isOpen: true,
    onClose: vi.fn(),
    onSave: vi.fn(),
    userId: '1',
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should render modal when open', () => {
    render(<ExamConfigModal {...mockProps} />);
    
    expect(screen.getByText('試験設定')).toBeInTheDocument();
    expect(screen.getByLabelText('試験日')).toBeInTheDocument();
    expect(screen.getByLabelText('目標点数')).toBeInTheDocument();
  });

  it('should not render when closed', () => {
    render(<ExamConfigModal {...mockProps} isOpen={false} />);
    
    expect(screen.queryByText('試験設定')).not.toBeInTheDocument();
  });

  it('should load existing config on mount', async () => {
    const mockConfig: ExamConfig = {
      id: 1,
      userId: 1,
      examDate: '2024-12-01T00:00:00Z',
      targetScore: 80,
      remainingDays: 30,
      createdAt: '2024-01-01T00:00:00Z',
      updatedAt: '2024-01-01T00:00:00Z',
    };

    mockApi.getExamConfig.mockResolvedValue(mockConfig);

    render(<ExamConfigModal {...mockProps} />);

    await waitFor(() => {
      expect(screen.getByDisplayValue('2024-12-01')).toBeInTheDocument();
      expect(screen.getByDisplayValue('80')).toBeInTheDocument();
    });
  });

  it('should handle form submission for new config', async () => {
    mockApi.getExamConfig.mockRejectedValue(new Error('Not found'));
    mockApi.setExamConfig.mockResolvedValue({
      id: 1,
      userId: 1,
      examDate: '2024-12-01T00:00:00Z',
      targetScore: 85,
      remainingDays: 30,
      createdAt: '2024-01-01T00:00:00Z',
      updatedAt: '2024-01-01T00:00:00Z',
    });

    render(<ExamConfigModal {...mockProps} />);

    // Fill form
    const examDateInput = screen.getByLabelText('試験日');
    const targetScoreInput = screen.getByLabelText('目標点数');
    
    fireEvent.change(examDateInput, { target: { value: '2024-12-01' } });
    fireEvent.change(targetScoreInput, { target: { value: '85' } });

    // Submit form
    const saveButton = screen.getByText('保存');
    fireEvent.click(saveButton);

    await waitFor(() => {
      expect(mockApi.setExamConfig).toHaveBeenCalledWith('1', {
        examDate: '2024-12-01T00:00:00.000Z',
        targetScore: 85,
      });
      expect(mockProps.onSave).toHaveBeenCalled();
    });
  });

  it('should handle form submission for existing config update', async () => {
    const existingConfig: ExamConfig = {
      id: 1,
      userId: 1,
      examDate: '2024-11-01T00:00:00Z',
      targetScore: 80,
      remainingDays: 30,
      createdAt: '2024-01-01T00:00:00Z',
      updatedAt: '2024-01-01T00:00:00Z',
    };

    mockApi.getExamConfig.mockResolvedValue(existingConfig);
    mockApi.updateExamConfig.mockResolvedValue({
      ...existingConfig,
      examDate: '2024-12-01T00:00:00Z',
      targetScore: 90,
    });

    render(<ExamConfigModal {...mockProps} />);

    await waitFor(() => {
      expect(screen.getByDisplayValue('2024-11-01')).toBeInTheDocument();
    });

    // Update form
    const examDateInput = screen.getByLabelText('試験日');
    const targetScoreInput = screen.getByLabelText('目標点数');
    
    fireEvent.change(examDateInput, { target: { value: '2024-12-01' } });
    fireEvent.change(targetScoreInput, { target: { value: '90' } });

    // Submit form
    const saveButton = screen.getByText('保存');
    fireEvent.click(saveButton);

    await waitFor(() => {
      expect(mockApi.updateExamConfig).toHaveBeenCalledWith('1', {
        examDate: '2024-12-01T00:00:00.000Z',
        targetScore: 90,
      });
      expect(mockProps.onSave).toHaveBeenCalled();
    });
  });

  it('should handle form validation errors', async () => {
    render(<ExamConfigModal {...mockProps} />);

    // Try to submit without filling required fields
    const saveButton = screen.getByText('保存');
    fireEvent.click(saveButton);

    await waitFor(() => {
      expect(screen.getByText('試験日を入力してください')).toBeInTheDocument();
    });

    expect(mockApi.setExamConfig).not.toHaveBeenCalled();
    expect(mockProps.onSave).not.toHaveBeenCalled();
  });

  it('should validate target score range', async () => {
    render(<ExamConfigModal {...mockProps} />);

    const examDateInput = screen.getByLabelText('試験日');
    const targetScoreInput = screen.getByLabelText('目標点数');
    
    fireEvent.change(examDateInput, { target: { value: '2024-12-01' } });
    fireEvent.change(targetScoreInput, { target: { value: '150' } }); // Invalid score

    const saveButton = screen.getByText('保存');
    fireEvent.click(saveButton);

    await waitFor(() => {
      expect(screen.getByText('目標点数は0-100の間で入力してください')).toBeInTheDocument();
    });
  });

  it('should validate exam date is in the future', async () => {
    render(<ExamConfigModal {...mockProps} />);

    const examDateInput = screen.getByLabelText('試験日');
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    
    fireEvent.change(examDateInput, { 
      target: { value: yesterday.toISOString().split('T')[0] }
    });

    const saveButton = screen.getByText('保存');
    fireEvent.click(saveButton);

    await waitFor(() => {
      expect(screen.getByText('試験日は今日以降の日付を選択してください')).toBeInTheDocument();
    });
  });

  it('should handle delete functionality', async () => {
    const existingConfig: ExamConfig = {
      id: 1,
      userId: 1,
      examDate: '2024-12-01T00:00:00Z',
      targetScore: 80,
      remainingDays: 30,
      createdAt: '2024-01-01T00:00:00Z',
      updatedAt: '2024-01-01T00:00:00Z',
    };

    mockApi.getExamConfig.mockResolvedValue(existingConfig);
    mockApi.deleteExamConfig.mockResolvedValue({ message: 'Deleted' });

    render(<ExamConfigModal {...mockProps} />);

    await waitFor(() => {
      expect(screen.getByDisplayValue('2024-12-01')).toBeInTheDocument();
    });

    const deleteButton = screen.getByText('削除');
    fireEvent.click(deleteButton);

    // Confirm deletion
    const confirmButton = screen.getByText('確認');
    fireEvent.click(confirmButton);

    await waitFor(() => {
      expect(mockApi.deleteExamConfig).toHaveBeenCalledWith('1');
      expect(mockProps.onSave).toHaveBeenCalled();
    });
  });

  it('should handle API errors gracefully', async () => {
    mockApi.getExamConfig.mockRejectedValue(new Error('Not found'));
    mockApi.setExamConfig.mockRejectedValue(new Error('Server error'));

    render(<ExamConfigModal {...mockProps} />);

    const examDateInput = screen.getByLabelText('試験日');
    fireEvent.change(examDateInput, { target: { value: '2024-12-01' } });

    const saveButton = screen.getByText('保存');
    fireEvent.click(saveButton);

    await waitFor(() => {
      expect(screen.getByText('エラーが発生しました: Server error')).toBeInTheDocument();
    });
  });

  it('should close modal when cancel is clicked', () => {
    render(<ExamConfigModal {...mockProps} />);

    const cancelButton = screen.getByText('キャンセル');
    fireEvent.click(cancelButton);

    expect(mockProps.onClose).toHaveBeenCalled();
  });

  it('should reset form when modal is closed and reopened', async () => {
    const { rerender } = render(<ExamConfigModal {...mockProps} />);

    // Fill form
    const examDateInput = screen.getByLabelText('試験日');
    fireEvent.change(examDateInput, { target: { value: '2024-12-01' } });

    // Close modal
    rerender(<ExamConfigModal {...mockProps} isOpen={false} />);

    // Reopen modal
    rerender(<ExamConfigModal {...mockProps} isOpen={true} />);

    // Form should be reset
    await waitFor(() => {
      const newExamDateInput = screen.getByLabelText('試験日');
      expect(newExamDateInput).toHaveValue('');
    });
  });

  it('should show loading state during API calls', async () => {
    mockApi.getExamConfig.mockReturnValue(new Promise(resolve => setTimeout(resolve, 100)));

    render(<ExamConfigModal {...mockProps} />);

    expect(screen.getByText('読み込み中...')).toBeInTheDocument();
  });
});