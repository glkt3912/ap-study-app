#!/usr/bin/env node

import fs from 'fs/promises'
import path from 'path'

/**
 * OpenAPIä»•æ§˜æ›¸ã‹ã‚‰TypeScriptå‹å®šç¾©ã‚’è‡ªå‹•ç”Ÿæˆã™ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
 */

const BACKEND_URL = process.env.BACKEND_URL || 'http://localhost:8000'
const OUTPUT_DIR = path.join(process.cwd(), 'src', 'types')
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'api.ts')

async function generateTypes() {
  try {
    console.log('ğŸ”„ OpenAPIä»•æ§˜æ›¸ã‹ã‚‰TypeScriptå‹ã‚’ç”Ÿæˆä¸­...')
    console.log(`ğŸ“¡ Backend URL: ${BACKEND_URL}/doc`)

    // å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
    await fs.mkdir(OUTPUT_DIR, { recursive: true })

    // OpenAPIä»•æ§˜æ›¸ã‚’å–å¾—ï¼ˆç¾åœ¨ã¯ç›´æ¥å‹å®šç¾©ã‚’ç”Ÿæˆï¼‰
    console.log('âœ… åŸºæœ¬å‹å®šç¾©ã‚’ç”Ÿæˆã—ã¾ã™')

    // åŸºæœ¬çš„ãªå‹å®šç¾©ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
    const fallbackTypes = `// Auto-generated from OpenAPI specification
// Do not edit this file manually

export interface StudyLog {
  id: number;
  userId: number;
  date: string;
  subjectId: number;
  topicId: number | null;
  studyTime: number;
  correctAnswers: number;
  totalQuestions: number;
  notes: string | null;
  createdAt: string;
  updatedAt: string;
}

export interface StudyPlan {
  id: number;
  userId: number;
  subjectId: number;
  startDate: string;
  endDate: string;
  targetHours: number;
  status: string;
  createdAt: string;
  updatedAt: string;
}

export interface AnalysisResult {
  id: number;
  userId: number;
  analysisDate: string;
  studyPattern: any;
  weaknessAnalysis: any;
  studyRecommendation: any;
  overallScore: number;
  createdAt: string;
  updatedAt: string;
}

export interface PredictionResult {
  id: number;
  userId: number;
  predictionDate: string;
  examDate: string;
  predictedScore: number;
  confidenceLevel: number;
  recommendations: any;
  createdAt: string;
  updatedAt: string;
}

export interface ReviewItem {
  id: number;
  userId: number;
  questionId: number;
  difficulty: number;
  lastReviewDate: string | null;
  nextReviewDate: string;
  reviewCount: number;
  masteryLevel: number;
  createdAt: string;
  updatedAt: string;
}

export interface Question {
  id: number;
  text: string;
  choices: string[];
  correctAnswer: number;
  explanation: string;
  category: string;
  difficulty: number;
  tags: string[];
}

export interface QuizSession {
  id: number;
  userId: number;
  sessionType: string;
  category?: string;
  totalQuestions: number;
  correctAnswers: number;
  score: number;
  totalTime: number;
  avgTimePerQ: number;
  isCompleted: boolean;
  createdAt: string;
  completedAt?: string;
}

// Additional utility types
export type ApiResponse<T> = {
  success: true;
  data: T;
} | {
  success: false;
  error: string;
};

export type CreateStudyLogRequest = Omit<StudyLog, 'id' | 'createdAt' | 'updatedAt'>;
export type UpdateStudyLogRequest = Partial<CreateStudyLogRequest>;

export type CreateStudyPlanRequest = Omit<StudyPlan, 'id' | 'createdAt' | 'updatedAt'>;
export type UpdateStudyPlanRequest = Partial<CreateStudyPlanRequest>;
`

    // ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
    await fs.writeFile(OUTPUT_FILE, fallbackTypes, 'utf8')

    console.log('âœ… TypeScriptå‹å®šç¾©ã‚’ç”Ÿæˆã—ã¾ã—ãŸ')
    console.log(`ğŸ“ å‡ºåŠ›å…ˆ: ${OUTPUT_FILE}`)

    // ç”Ÿæˆã•ã‚ŒãŸå‹ã®æ•°ã‚’è¡¨ç¤º
    const typeCount = (fallbackTypes.match(/export type/g) || []).length
    const interfaceCount = (fallbackTypes.match(/export interface/g) || []).length
    console.log(`ğŸ“Š ç”Ÿæˆã•ã‚ŒãŸå‹: ${typeCount} types, ${interfaceCount} interfaces`)

  } catch (error) {
    console.error('âŒ å‹ç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error.message)
    
    // ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ - æ—¢å­˜ã®api.tsã‚’ä¿æŒ
    console.log('ğŸ’¡ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ—¢å­˜ã®api.tsãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿æŒã—ã¾ã™')
    
    // æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯åŸºæœ¬å‹ã‚’ä½œæˆ
    try {
      await fs.access(OUTPUT_FILE)
      console.log('âœ… æ—¢å­˜ã®api.tsãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã™')
    } catch {
      console.log('ğŸ“ åŸºæœ¬çš„ãªå‹å®šç¾©ã‚’ä½œæˆã—ã¾ã™')
      const basicTypes = `// Basic type definitions (fallback)
export interface StudyLog {
  id: number;
  userId: number;
  date: string;
  subjectId: number;
  topicId: number | null;
  studyTime: number;
  correctAnswers: number;
  totalQuestions: number;
  notes: string | null;
  createdAt: string;
  updatedAt: string;
}

export type ApiResponse<T> = {
  success: true;
  data: T;
} | {
  success: false;
  error: string;
};
`
      await fs.writeFile(OUTPUT_FILE, basicTypes, 'utf8')
    }
  }
}

// ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œæ™‚ã«ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®èµ·å‹•ç¢ºèª
async function checkBackend() {
  try {
    const response = await fetch(`${BACKEND_URL}/`)
    if (response.ok) {
      console.log('âœ… ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã—ã¦ã„ã¾ã™')
      return true
    }
  } catch (error) {
    console.log('âš ï¸  ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“')
    return false
  }
  return false
}

async function main() {
  console.log('ğŸš€ APIå‹ç”Ÿæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆé–‹å§‹')
  
  const backendRunning = await checkBackend()
  if (!backendRunning) {
    console.log('ğŸ’¡ ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚’èµ·å‹•ã—ã¦ã‹ã‚‰å†å®Ÿè¡Œã—ã¦ãã ã•ã„')
    process.exit(1)
  }
  
  await generateTypes()
  console.log('ğŸ‰ å‹ç”Ÿæˆå®Œäº†!')
}

main()