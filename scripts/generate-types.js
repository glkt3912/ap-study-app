#!/usr/bin/env node

import fs from 'fs/promises'
import path from 'path'
import openapiTS from 'openapi-typescript'

/**
 * OpenAPIä»•æ§˜æ›¸ã‹ã‚‰TypeScriptå‹å®šç¾©ã‚’è‡ªå‹•ç”Ÿæˆã™ã‚‹ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
 */

const BACKEND_URL = process.env.BACKEND_URL || 'http://localhost:8000'
const OUTPUT_DIR = path.join(process.cwd(), 'src', 'types')
const OUTPUT_FILE = path.join(OUTPUT_DIR, 'api.ts')

async function generateTypes() {
  try {
    console.log('ğŸ”„ OpenAPIä»•æ§˜æ›¸ã‹ã‚‰TypeScriptå‹ã‚’ç”Ÿæˆä¸­...')
    console.log(`ğŸ“¡ Backend URL: ${BACKEND_URL}/doc`)

    // OpenAPIä»•æ§˜æ›¸ã‚’å–å¾—
    const response = await fetch(`${BACKEND_URL}/doc`)
    if (!response.ok) {
      throw new Error(`Failed to fetch OpenAPI spec: ${response.statusText}`)
    }

    const spec = await response.json()
    console.log('âœ… OpenAPIä»•æ§˜æ›¸ã‚’å–å¾—ã—ã¾ã—ãŸ')

    // TypeScriptå‹å®šç¾©ã‚’ç”Ÿæˆ
    const output = await openapiTS(spec, {
      transform: {
        camelCase: true,
      },
    })

    // å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
    await fs.mkdir(OUTPUT_DIR, { recursive: true })

    // è¿½åŠ ã®å‹å®šç¾©ã¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚’å«ã‚ã‚‹
    const typeDefinitions = `// Auto-generated from OpenAPI specification
// Do not edit this file manually

${output}

// Additional utility types
export type ApiResponse<T> = {
  success: true
  data: T
} | {
  success: false
  error: string
}

// API paths type helper
export type ApiPaths = paths

// API operation types
export type GetStudyPlanResponse = ApiResponse<components['schemas']['StudyWeek'][]>
export type GetStudyLogResponse = ApiResponse<components['schemas']['StudyLog'][]>
export type CreateStudyLogRequest = components['schemas']['CreateStudyLog']
export type CreateStudyLogResponse = ApiResponse<components['schemas']['StudyLog']>

// Request/Response type helpers
export type PathParams<T extends keyof paths> = paths[T] extends { parameters: { path: infer P } } ? P : never
export type QueryParams<T extends keyof paths> = paths[T] extends { parameters: { query: infer Q } } ? Q : never
export type RequestBody<T extends keyof paths, M extends keyof paths[T]> = 
  paths[T][M] extends { requestBody: { content: { 'application/json': infer B } } } ? B : never
export type ResponseBody<T extends keyof paths, M extends keyof paths[T], S extends number> = 
  paths[T][M] extends { responses: { [K in S]: { content: { 'application/json': infer R } } } } ? R : never

// Export commonly used schemas
export type StudyWeek = components['schemas']['StudyWeek']
export type StudyDay = components['schemas']['StudyDay']
export type StudyLog = components['schemas']['StudyLog']
export type MorningTest = components['schemas']['MorningTest']
export type AfternoonTest = components['schemas']['AfternoonTest']
export type Question = components['schemas']['Question']
export type QuizSession = components['schemas']['QuizSession']
`

    // ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
    await fs.writeFile(OUTPUT_FILE, typeDefinitions, 'utf8')

    console.log('âœ… TypeScriptå‹å®šç¾©ã‚’ç”Ÿæˆã—ã¾ã—ãŸ')
    console.log(`ğŸ“ å‡ºåŠ›å…ˆ: ${OUTPUT_FILE}`)

    // ç”Ÿæˆã•ã‚ŒãŸå‹ã®æ•°ã‚’è¡¨ç¤º
    const typeCount = (typeDefinitions.match(/export type/g) || []).length
    const interfaceCount = (typeDefinitions.match(/export interface/g) || []).length
    console.log(`ğŸ“Š ç”Ÿæˆã•ã‚ŒãŸå‹: ${typeCount} types, ${interfaceCount} interfaces`)

  } catch (error) {
    console.error('âŒ å‹ç”Ÿæˆã‚¨ãƒ©ãƒ¼:', error.message)
    
    // ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãŒèµ·å‹•ã—ã¦ã„ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    if (error.message.includes('fetch')) {
      console.log('ğŸ’¡ ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™')
      console.log('ğŸ’¡ ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã§ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚’èµ·å‹•ã—ã¦ã‹ã‚‰å†å®Ÿè¡Œã—ã¦ãã ã•ã„:')
      console.log('   cd ../ap-study-backend && npm run dev')
    }
    
    process.exit(1)
  }
}

// ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œæ™‚ã«ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®èµ·å‹•ç¢ºèª
async function checkBackend() {
  try {
    const response = await fetch(`${BACKEND_URL}/`)
    if (response.ok) {
      console.log('âœ… ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã—ã¦ã„ã¾ã™')
      return true
    }
  } catch (error) {
    console.log('âš ï¸  ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“')
    return false
  }
  return false
}

async function main() {
  console.log('ğŸš€ APIå‹ç”Ÿæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆé–‹å§‹')
  
  const backendRunning = await checkBackend()
  if (!backendRunning) {
    console.log('ğŸ’¡ ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚’èµ·å‹•ã—ã¦ã‹ã‚‰å†å®Ÿè¡Œã—ã¦ãã ã•ã„')
    process.exit(1)
  }
  
  await generateTypes()
  console.log('ğŸ‰ å‹ç”Ÿæˆå®Œäº†!')
}

main()